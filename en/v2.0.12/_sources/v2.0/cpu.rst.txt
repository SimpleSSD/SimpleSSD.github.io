************************
Firmware Execution Model
************************

In this page, we will explain how we design and implement firmware execution model (embedded CPU).

This model stores **the number of instructions per function**, which is calculated by aarch64 compiler.
When the function called, corresponding instructions are added to statistics.

You can configure total number of cores dedicated to each firmware component (HIL, ICL and FTL).

* ``HILCoreCount``: # cores dedicated to HIL functions.
* ``ICLCoreCount``: # cores dedicated to ICL functions.
* ``FTLCoreCount``: # cores dedicated to FTL functions.

If you set core count as zero, firmware execution latency will not added.


CPU and Core
============

The core is defined as ``SimpleSSD::CPU::CPU::Core`` in ``cpu/cpu.hh``.
Instruction accumulation will be performed in ``SimpleSSD::CPU::CPU``.

``CPU`` class will select ``Core`` which has lease utilization at time point.
``CPU::execute`` and ``CPU::applyLatency`` functions will add up instructions to ``Core`` statistics.

All functions related to I/O handling has instruction count.
This value is hard-coded into the source-code (See ``CPU::CPU`` constructor).
The value is auto-generated by python script, it generates total number of instructions from specified file and function.
You can find script at ``cpu/generator/generate.py``.
To use script, you need ``aarch64-linux-gnu-g++`` and ``aarch64-linux-gnu-objdump``.
For installing these program (ARMv8 toolchain), see :ref:`tips_kernel_toolchain`.
